diff -Naru shm/gstshmsink.c /tmp/shm/gstshmsink.c
--- shm/gstshmsink.c	2023-06-09 10:10:18.282401109 +0200
+++ /tmp/shm/gstshmsink.c	2023-06-09 10:10:05.774300662 +0200
@@ -41,6 +41,7 @@
 #include <gst/gst.h>
 
 #include <string.h>
+#include <gst/video/video-info.h>
 
 /* signals */
 enum
@@ -309,10 +310,9 @@
   GST_OBJECT_UNLOCK (self->sink);
 
   if (!memory) {
-    memory = gst_allocator_alloc (NULL, size, params);
-    GST_LOG_OBJECT (self,
+    GST_ERROR_OBJECT (self,
         "Not enough shared memory for GstMemory of %" G_GSIZE_FORMAT
-        "bytes, allocating using standard allocator", size);
+        "bytes", size);
   }
 
   return memory;
@@ -725,20 +725,6 @@
       goto error;
     }
 
-    while ((memory =
-            gst_shm_sink_allocator_alloc_locked (self->allocator,
-                gst_buffer_get_size (buf), &self->params)) == NULL) {
-      g_cond_wait (&self->cond, GST_OBJECT_GET_LOCK (self));
-      if (self->unlock) {
-        GST_OBJECT_UNLOCK (self);
-        ret = gst_base_sink_wait_preroll (bsink);
-        if (ret == GST_FLOW_OK)
-          GST_OBJECT_LOCK (self);
-        else
-          return ret;
-      }
-    }
-
     while (self->wait_for_connection && !self->clients) {
       g_cond_wait (&self->cond, GST_OBJECT_GET_LOCK (self));
       if (self->unlock) {
@@ -747,12 +733,26 @@
         if (ret == GST_FLOW_OK) {
           GST_OBJECT_LOCK (self);
         } else {
-          gst_memory_unref (memory);
           return ret;
         }
       }
     }
 
+    if (!self->clients) {
+      GST_DEBUG_OBJECT (self, "No clients connected, skip buffer");
+      GST_OBJECT_UNLOCK (self);
+      return GST_FLOW_OK;
+    }
+
+    memory = gst_shm_sink_allocator_alloc_locked (self->allocator,
+        gst_buffer_get_size (buf), &self->params);
+
+    if (memory == NULL) {
+      GST_WARNING_OBJECT (self, "No free shared memory blocks, skip input buffer");
+      GST_OBJECT_UNLOCK (self);
+      return GST_FLOW_OK;
+    }
+
     if (!gst_memory_map (memory, &map, GST_MAP_WRITE)) {
       GST_ELEMENT_ERROR (self, STREAM, FAILED,
           (NULL), ("Failed to map memory"));
@@ -1002,10 +1002,112 @@
 gst_shm_sink_propose_allocation (GstBaseSink * sink, GstQuery * query)
 {
   GstShmSink *self = GST_SHM_SINK (sink);
+  GstCaps *caps = NULL;
+  gboolean need_pool = FALSE;
+  guint pool_count = 0;
+  guint params_count = 0;
+  guint buffer_size = 0;
+  guint min_buffers = 0;
+  guint max_buffers = 0;
+  guint buffer_size_tmp = 0;
+  guint prefix = 0;
+  guint padding = 0;
+  guint align = 0;
+  GstVideoInfo info;
+  GstAllocationParams params;
+  GstStructure *config = NULL;
+  GstBufferPool *pool = NULL;
 
-  if (self->allocator)
-    gst_query_add_allocation_param (query, GST_ALLOCATOR (self->allocator),
-        NULL);
+  // propose buffer pool if possible
+  gst_query_parse_allocation (query, &caps, &need_pool);
+
+  if (need_pool == FALSE) {
+    GST_WARNING_OBJECT (self, "No pool requested");
+    return FALSE;
+  }
+
+  if (caps == NULL) {
+    GST_WARNING_OBJECT (self, "Allocation query doesn't contain caps");
+    return FALSE;
+  }
+
+  if (gst_video_info_from_caps(&info, caps) == FALSE) {
+    GST_ERROR_OBJECT (self, "Allocation query contains invalid caps");
+    return FALSE;
+  }
+
+  if (self->allocator) {
+    pool_count = gst_query_get_n_allocation_pools (query);
+
+    for (int i = 0; i < pool_count; i++) {
+      gst_query_parse_nth_allocation_pool (query, i, NULL, &buffer_size_tmp,
+          NULL, NULL);
+      buffer_size = MAX(buffer_size, buffer_size_tmp);
+    }
+
+    params_count = gst_query_get_n_allocation_params (query);
+    for (int i = 0; i < params_count; i++) {
+      gst_query_parse_nth_allocation_param (query, i, NULL, &params);
+      prefix = MAX (prefix, params.prefix);
+      padding = MAX (padding, params.padding);
+      align = MAX (align, params.align);
+    }
+
+    GST_DEBUG_OBJECT (self, "Pool count:      %u", pool_count);
+    GST_DEBUG_OBJECT (self, "Max buffer size: %u", buffer_size);
+    GST_DEBUG_OBJECT (self, "Params count:    %u", params_count);
+    GST_DEBUG_OBJECT (self, "Max prefix:      %u", prefix);
+    GST_DEBUG_OBJECT (self, "Max padding:     %u", padding);
+    GST_DEBUG_OBJECT (self, "Max align:       %u", align);
+
+    if (buffer_size == 0) {
+      buffer_size = info.size;
+    }
+
+    if (buffer_size != 0) {
+      // XXX shm allocator adds additional memory alignment, so we need count
+      // that during calculation of maximum buffer size
+      align |= gst_memory_alignment;
+
+      GST_OBJECT_LOCK (self);
+      max_buffers = self->size / (prefix + buffer_size + padding + align);
+      GST_OBJECT_UNLOCK (self);
+
+
+      pool = gst_buffer_pool_new ();
+      if (pool == NULL) {
+        GST_ERROR_OBJECT (self, "Can not create gst buffer pool");
+        return FALSE;
+      }
+      
+      config = gst_buffer_pool_get_config (pool);
+
+      gst_buffer_pool_config_set_allocator (config,
+          GST_ALLOCATOR (self->allocator), NULL);
+      gst_buffer_pool_config_set_params (config, caps, buffer_size, min_buffers,
+          max_buffers);
+
+      if (gst_buffer_pool_set_config (pool, config) == FALSE) {
+        GST_ERROR_OBJECT (self, "Can not set config for pool");
+        gst_object_unref(pool);
+        return FALSE;
+      }
+
+      GST_DEBUG_OBJECT (self, "Add allocation pool: size %u, min %u, max %u",
+          buffer_size, min_buffers, max_buffers);
+
+      gst_buffer_pool_set_active (pool, TRUE);
+
+      gst_query_add_allocation_pool (query, pool, buffer_size, min_buffers,
+          max_buffers);
+
+      gst_object_unref (pool);
+    } else {
+      GST_WARNING_OBJECT (self, "Can not calculate buffer size for buffer pool,"
+          " skip buffer pool creation, that can hurt perfomance!!!");
+      return FALSE;
+    }
+  }
 
   return TRUE;
 }
diff -Naru shm/Makefile.am /tmp/shm/Makefile.am
--- shm/Makefile.am	2023-06-09 10:10:18.282401109 +0200
+++ /tmp/shm/Makefile.am	2023-06-09 10:10:05.774300662 +0200
@@ -3,6 +3,6 @@
 libgstshm_la_SOURCES = shmpipe.c shmalloc.c gstshm.c gstshmsrc.c gstshmsink.c
 libgstshm_la_CFLAGS = $(GST_PLUGINS_BAD_CFLAGS) $(GST_CFLAGS) -DSHM_PIPE_USE_GLIB
 libgstshm_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
-libgstshm_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS) $(SHM_LIBS)
+libgstshm_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS) $(SHM_LIBS) -lgstvideo-$(GST_API_VERSION)
 
 noinst_HEADERS = gstshmsrc.h gstshmsink.h shmpipe.h  shmalloc.h
diff -Naru shm/meson.build /tmp/shm/meson.build
--- shm/meson.build	2023-06-09 10:10:18.286401141 +0200
+++ /tmp/shm/meson.build	2023-06-09 10:10:05.774300662 +0200
@@ -24,7 +24,7 @@
     shm_sources,
     c_args : gst_plugins_bad_args + ['-DSHM_PIPE_USE_GLIB'],
     include_directories : [configinc],
-    dependencies : shm_deps,
+    dependencies : [shm_deps, gstvideo_dep],
     install : true,
     install_dir : plugins_install_dir,
   )
